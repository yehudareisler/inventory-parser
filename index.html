<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="utf-8">
<title>inventory parser</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    background: #0c0c0c;
    color: #cccccc;
    font-family: 'Cascadia Mono', Consolas, 'Courier New', monospace;
    font-size: 14px;
    padding: 20px;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
#main {
    flex: 1;
    display: flex;
    gap: 16px;
    min-height: 0;
}
#left-pane {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 0;
}
#right-pane {
    flex: 1.2;
    display: flex;
    flex-direction: column;
    min-width: 0;
    overflow-y: auto;
}
#raw-input {
    flex: 1;
    width: 100%;
    background: #1a1a1a;
    border: 1px solid #333;
    border-radius: 4px;
    color: #cccccc;
    font-family: inherit;
    font-size: inherit;
    padding: 10px;
    resize: none;
    direction: rtl;
    outline: none;
    word-wrap: break-word;
    overflow-wrap: break-word;
}
#raw-input:focus { border-color: #555; }
#raw-input::placeholder { color: #666; }
#raw-input.stale { border-color: #806020; }
#reparse-hint {
    display: none;
    color: #e0a040;
    font-size: 12px;
    margin-top: 2px;
}
#buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 8px;
}
.btn {
    background: #222;
    border: 1px solid #444;
    border-radius: 4px;
    color: #ccc;
    font-family: inherit;
    font-size: 13px;
    padding: 6px 14px;
    cursor: pointer;
    transition: background 0.15s;
}
.btn:hover { background: #333; border-color: #666; }
.btn-primary { background: #1a4a1a; border-color: #2a6a2a; }
.btn-parsed { background: #1a3a1a; border-color: #2a5a2a; color: #6a6; cursor: default; }
.btn-primary:hover { background: #2a5a2a; }
.btn-danger { background: #4a1a1a; border-color: #6a2a2a; }
.btn-danger:hover { background: #5a2a2a; }
table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 12px;
    table-layout: auto;
}
th {
    background: #1a1a1a;
    border: 1px solid #333;
    padding: 6px 8px;
    text-align: right;
    font-weight: bold;
    white-space: nowrap;
}
td {
    border: 1px solid #333;
    padding: 4px 8px;
    cursor: pointer;
    word-wrap: break-word;
    overflow-wrap: break-word;
    max-width: 200px;
}
td:hover { background: #1a1a1a; }
td.editing { padding: 2px; }
td.editing input, td.editing select {
    width: 100%;
    background: #111;
    border: 1px solid #555;
    color: #ccc;
    font-family: inherit;
    font-size: inherit;
    padding: 3px 5px;
    direction: rtl;
}
.warn { color: #e0a040; }
.note { color: #80a0c0; margin: 4px 0; word-wrap: break-word; }
.unparse { color: #c08060; margin: 4px 0; word-wrap: break-word; }
.status { color: #60c060; margin: 8px 0; word-wrap: break-word; }
.error { color: #c06060; margin: 8px 0; word-wrap: break-word; }
.row-num {
    text-align: center;
    cursor: default;
    min-width: 30px;
}
.delete-btn {
    color: #c06060;
    cursor: pointer;
    text-align: center;
    min-width: 24px;
}
.delete-btn:hover { color: #ff6060; background: #2a1a1a; }
/* Modal overlay */
.modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
}
.modal {
    background: #1a1a1a;
    border: 1px solid #444;
    border-radius: 8px;
    padding: 20px;
    min-width: 320px;
    max-width: 500px;
    max-height: 80vh;
    overflow-y: auto;
    direction: rtl;
}
.modal h3 { margin-bottom: 12px; color: #ddd; }
.modal .context { color: #888; font-size: 12px; margin-bottom: 10px; word-wrap: break-word; }
.modal label { display: block; margin-bottom: 6px; color: #aaa; }
.modal input[type=text], .modal input[type=number] {
    width: 100%;
    background: #111;
    border: 1px solid #555;
    border-radius: 4px;
    color: #ccc;
    font-family: inherit;
    font-size: inherit;
    padding: 6px 8px;
    margin-bottom: 10px;
    direction: rtl;
}
.modal .modal-buttons { display: flex; gap: 8px; justify-content: flex-start; margin-top: 12px; }
.modal .fuzzy-confirm { color: #e0a040; margin: 6px 0; }
/* Help panel */
#help-panel {
    display: none;
    background: #1a1a1a;
    border: 1px solid #333;
    border-radius: 4px;
    padding: 12px;
    margin-bottom: 8px;
    font-size: 13px;
    max-height: 60vh;
    overflow-y: auto;
}
#help-panel h4 { color: #ddd; margin: 8px 0 4px 0; }
#help-panel h4:first-child { margin-top: 0; }
#help-panel .help-list { color: #aaa; margin: 2px 0 2px 16px; }
</style>
</head>
<body>
<div id="main">
    <div id="left-pane">
        <textarea id="raw-input" autofocus></textarea>
        <div id="reparse-hint"></div>
        <div id="buttons"></div>
    </div>
    <div id="right-pane">
        <div id="help-panel"></div>
        <div id="output"></div>
    </div>
</div>
<script>
const $ = s => document.querySelector(s);
const output = $('#output');
const rawInput = $('#raw-input');
const buttons = $('#buttons');
const reparseHint = $('#reparse-hint');
const helpPanel = $('#help-panel');

let state = { rows: [], notes: [], unparseable: [], phase: 'idle' };
let cfg = { items: [], locations: [], transaction_types: [], aliases: {}, ui: {}, closed_set_options: {}, required_fields: [], field_order: [] };
let editingCell = null;
let parsedText = '';  // track what was last parsed

// Fetch config on load
async function loadConfig() {
    try {
        const r = await fetch('/api/config');
        cfg = await r.json();
        rawInput.placeholder = cfg.ui.paste_prompt || '';
        renderButtons();
        buildHelp();
    } catch(e) { console.error('loadConfig failed', e); }
}
loadConfig();

function s(key, vars) {
    let t = (cfg.ui && cfg.ui.strings && cfg.ui.strings[key]) || key;
    if (vars) {
        for (const [k, v] of Object.entries(vars)) {
            t = t.replace(new RegExp('\\{' + k + '\\}', 'g'), v);
        }
    }
    return t;
}

function cmd(key) {
    return (cfg.ui && cfg.ui.commands && cfg.ui.commands[key]) || key;
}

// ---- Auto-reparse on newline ----
let parseTimer = null;
rawInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        // Debounce: wait a tick so the newline is inserted first
        clearTimeout(parseTimer);
        parseTimer = setTimeout(() => doParse(), 50);
    }
});

// ---- Re-parse indicator (B2) ----
rawInput.addEventListener('input', () => {
    if (state.phase === 'parsed' && rawInput.value.trim() !== parsedText) {
        rawInput.classList.add('stale');
        reparseHint.style.display = 'block';
        reparseHint.textContent = s('review_parse_btn') + ' \u2190';
    } else {
        rawInput.classList.remove('stale');
        reparseHint.style.display = 'none';
    }
});

// ---- Closed-set fields from server-resolved data ----
function getClosedFields() {
    return Object.keys(cfg.closed_set_options || {});
}

function getFieldOptions(field) {
    return (cfg.closed_set_options || {})[field] || [];
}

// ---- Warning check from config (A2) ----
function rowHasWarning(row) {
    const required = cfg.required_fields || ['trans_type', 'vehicle_sub_unit'];
    return required.some(f => row[f] == null || row[f] === '???');
}

function getIncompleteRows() {
    const incomplete = [];
    const required = cfg.required_fields || ['trans_type', 'vehicle_sub_unit'];
    for (let i = 0; i < state.rows.length; i++) {
        const row = state.rows[i];
        if (row.inv_type === '???' || required.some(f => row[f] == null)) {
            incomplete.push(i + 1);
        }
    }
    return incomplete;
}

// ---- Buttons ----
function renderButtons() {
    buttons.innerHTML = '';
    const mkBtn = (label, cls, fn) => {
        const b = document.createElement('button');
        b.className = 'btn ' + (cls || '');
        b.textContent = label;
        b.onclick = fn;
        buttons.appendChild(b);
        return b;
    };

    if (state.phase === 'idle' || state.phase === 'parsed') {
        const parseLabel = s('review_parse_btn') || 'Parse';
        const isStale = state.phase === 'parsed' && rawInput.value.trim() !== parsedText;
        const isParsed = state.phase === 'parsed' && !isStale;
        const parseCls = isParsed ? 'btn-parsed' : 'btn-primary';
        const btn = mkBtn(isParsed ? '\u2713 ' + parseLabel : parseLabel, parseCls, doParse);
        if (isParsed) btn.title = 'Already parsed';
    }
    if (state.phase === 'parsed' && state.rows.length > 0) {
        mkBtn(s('review_confirm_btn') || cmd('confirm'), 'btn-primary', doConfirm);
    }
    mkBtn(s('cmd_alias') || 'alias', '', () => showAliasModal());
    mkBtn(s('cmd_convert') || 'convert', '', () => showConvertModal());
    mkBtn('?', '', toggleHelp);
}

// ---- Parse ----
async function doParse() {
    const text = rawInput.value.trim();
    if (!text) return;
    try {
        const r = await fetch('/api/parse', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({text})
        });
        const d = await r.json();
        state.rows = d.rows || [];
        state.notes = d.notes || [];
        state.unparseable = d.unparseable || [];
        state.phase = 'parsed';
        parsedText = text;
        rawInput.classList.remove('stale');
        reparseHint.style.display = 'none';
        renderAll();
    } catch(e) { showError('Parse failed: ' + e); }
}

// ---- Confirm (B1: incomplete warning) ----
async function doConfirm() {
    if (!state.rows.length) return;

    // B1: Check for incomplete fields before confirming
    const incomplete = getIncompleteRows();
    if (incomplete.length) {
        const rowList = incomplete.join(', ');
        const msg = s('confirm_incomplete_warning', {
            row_list: rowList,
            yes: cmd('yes'),
            no: cmd('no')
        });
        if (!confirm(msg)) return;
    }

    try {
        const r = await fetch('/api/confirm', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({rows: state.rows})
        });
        const d = await r.json();
        if (d.clip) {
            try { await navigator.clipboard.writeText(d.clip); }
            catch(e) { console.warn('clipboard failed', e); }
        }
        showStatus(s('clipboard_copied', {count: String(d.count)}) || d.count + ' rows copied');

        // Alias learning
        if (d.alias_prompts && d.alias_prompts.length) {
            for (const [orig, canon] of d.alias_prompts) {
                if (confirm(s('save_alias_prompt', {original: orig, canonical: canon, yes: cmd('yes'), no: cmd('no')}))) {
                    await fetch('/api/alias', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({alias: orig, target: canon})
                    });
                }
            }
        }
        // Conversion learning â€” use modal
        if (d.conv_prompts && d.conv_prompts.length) {
            for (const [item, container] of d.conv_prompts) {
                await showConvertLearnModal(item, container);
            }
        }

        state.rows = [];
        state.notes = [];
        state.unparseable = [];
        state.phase = 'idle';
        parsedText = '';
        rawInput.value = '';
        await loadConfig();
        renderAll();
    } catch(e) { showError('Confirm failed: ' + e); }
}

// ---- Add row ----
// ---- Delete row ----
async function doDelete(idx) {
    try {
        const r = await fetch('/api/delete', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({rows: state.rows, row_idx: idx})
        });
        const d = await r.json();
        state.rows = d.rows;
        if (d.warning) showStatus(d.warning);
        renderAll();
    } catch(e) { showError(e); }
}

// ---- Edit cell ----
function startEdit(td, rowIdx, field) {
    if (editingCell) cancelEdit();
    editingCell = { td, rowIdx, field };
    td.classList.add('editing');

    const closedFields = getClosedFields();
    const currentVal = state.rows[rowIdx][field];

    if (closedFields.includes(field)) {
        const sel = document.createElement('select');
        const options = getFieldOptions(field);
        for (const opt of options) {
            const o = document.createElement('option');
            o.value = opt;
            o.textContent = opt;
            if (opt === currentVal) o.selected = true;
            sel.appendChild(o);
        }
        sel.onchange = () => commitEdit(sel.value);
        sel.onkeydown = e => { if (e.key === 'Escape') cancelEdit(); };
        td.textContent = '';
        td.appendChild(sel);
        sel.focus();
    } else {
        const inp = document.createElement('input');
        inp.value = currentVal != null ? String(currentVal) : '';
        inp.onkeydown = e => {
            if (e.key === 'Enter') { e.preventDefault(); commitEdit(inp.value); }
            if (e.key === 'Escape') cancelEdit();
        };
        inp.onblur = () => setTimeout(() => { if (editingCell) cancelEdit(); }, 100);
        td.textContent = '';
        td.appendChild(inp);
        inp.focus();
        inp.select();
    }
}

async function commitEdit(value) {
    if (!editingCell) return;
    const { rowIdx, field } = editingCell;
    editingCell = null;
    try {
        const r = await fetch('/api/edit', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({rows: state.rows, row_idx: rowIdx, field, value})
        });
        const d = await r.json();
        if (d.error) { showError(d.error); renderAll(); return; }
        state.rows = d.rows;
        renderAll();
    } catch(e) { showError(e); renderAll(); }
}

function cancelEdit() {
    editingCell = null;
    renderAll();
}

// ============================================================
// Modal system (B4: replaces prompt() with context-rich dialogs)
// ============================================================

function createModal(title) {
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    const modal = document.createElement('div');
    modal.className = 'modal';
    const h3 = document.createElement('h3');
    h3.textContent = title;
    modal.appendChild(h3);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
    return { overlay, modal };
}

function addContext(modal, label, items) {
    if (!items || !items.length) return;
    const ctx = document.createElement('div');
    ctx.className = 'context';
    ctx.textContent = label + ' ' + items.join(', ');
    modal.appendChild(ctx);
}

function addInput(modal, label, id, type) {
    const lbl = document.createElement('label');
    lbl.textContent = label;
    modal.appendChild(lbl);
    const inp = document.createElement('input');
    inp.type = type || 'text';
    inp.id = id;
    modal.appendChild(inp);
    return inp;
}

function addButtons(modal, overlay, onOk, okLabel, cancelLabel) {
    const div = document.createElement('div');
    div.className = 'modal-buttons';
    const okBtn = document.createElement('button');
    okBtn.className = 'btn btn-primary';
    okBtn.textContent = okLabel || 'OK';
    okBtn.onclick = () => onOk(overlay);
    div.appendChild(okBtn);
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn';
    cancelBtn.textContent = cancelLabel || s('edit_cancelled').trim() || 'Cancel';
    cancelBtn.onclick = () => overlay.remove();
    div.appendChild(cancelBtn);
    modal.appendChild(div);
}

// ---- Alias modal (B4 + B5) ----
function showAliasModal() {
    const { overlay, modal } = createModal(s('cmd_alias'));
    addContext(modal, s('help_items_header'), cfg.items);
    addContext(modal, s('help_locations_header'), cfg.locations);
    if (cfg.aliases && Object.keys(cfg.aliases).length) {
        const aliasLines = Object.entries(cfg.aliases).map(([a,t]) => a + ' \u2192 ' + t);
        addContext(modal, s('help_aliases_header'), aliasLines);
    }
    const aliasInp = addInput(modal, s('alias_short_prompt'), 'modal-alias', 'text');
    const targetInp = addInput(modal, s('alias_maps_to_prompt'), 'modal-target', 'text');

    const fuzzyDiv = document.createElement('div');
    fuzzyDiv.className = 'fuzzy-confirm';
    fuzzyDiv.style.display = 'none';
    modal.appendChild(fuzzyDiv);

    addButtons(modal, overlay, async (ov) => {
        const alias = aliasInp.value.trim();
        const target = targetInp.value.trim();
        if (!alias || !target) return;

        const r = await fetch('/api/alias', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({alias, target})
        });
        const d = await r.json();

        // B5: fuzzy match confirmation
        if (d.ok && d.match_type === 'fuzzy') {
            const confirmMsg = s('fuzzy_confirm', {resolved: d.resolved, yes: cmd('yes'), no: cmd('no')});
            if (!confirm(confirmMsg)) {
                // Undo: re-save without this alias
                // For simplicity, just warn and let user fix manually
                ov.remove();
                return;
            }
        }

        if (d.ok) {
            showStatus(s('alias_saved', {alias, item: d.resolved || target}));
            await loadConfig();
        }
        ov.remove();
    }, s('review_confirm_btn'));

    aliasInp.focus();
}

// ---- Convert modal (B4) ----
function showConvertModal() {
    const { overlay, modal } = createModal(s('cmd_convert'));
    addContext(modal, s('help_items_header'), cfg.items);
    // Show known containers
    const containers = new Set();
    for (const convs of Object.values(cfg.unit_conversions || {})) {
        for (const k of Object.keys(convs)) {
            if (k !== 'base_unit') containers.add(k);
        }
    }
    if (containers.size) {
        addContext(modal, s('convert_container_prompt').replace(':','') + ':', [...containers]);
    }
    const itemInp = addInput(modal, s('convert_item_prompt'), 'modal-conv-item', 'text');
    const contInp = addInput(modal, s('convert_container_prompt'), 'modal-conv-cont', 'text');
    const factorInp = addInput(modal, s('convert_factor_prompt', {container: '...'}), 'modal-conv-factor', 'number');

    addButtons(modal, overlay, async (ov) => {
        const item = itemInp.value.trim();
        const container = contInp.value.trim();
        const factor = factorInp.value.trim();
        if (!item || !container || !factor || isNaN(parseFloat(factor))) return;

        const r = await fetch('/api/conversion', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({item, container, factor: parseFloat(factor)})
        });
        const d = await r.json();
        if (d.ok) {
            showStatus(s('conversion_saved', {item: d.item || item, container: d.container || container, factor}));
            await loadConfig();
        }
        ov.remove();
    }, s('review_confirm_btn'));

    itemInp.focus();
}

// ---- Convert learn modal (post-confirm) ----
function showConvertLearnModal(item, container) {
    return new Promise(resolve => {
        const { overlay, modal } = createModal(s('save_conversion_prompt', {item, container}));
        const factorInp = addInput(modal, s('convert_factor_prompt', {container}), 'modal-learn-factor', 'number');
        addButtons(modal, overlay, async (ov) => {
            const factor = factorInp.value.trim();
            if (factor && !isNaN(parseFloat(factor))) {
                await fetch('/api/conversion', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({item, container, factor: parseFloat(factor)})
                });
            }
            ov.remove();
            resolve();
        }, s('review_confirm_btn'));
        const skipBtn = modal.querySelector('.modal-buttons .btn:not(.btn-primary)');
        if (skipBtn) {
            const origClick = skipBtn.onclick;
            skipBtn.onclick = () => { origClick(); resolve(); };
        }
        factorInp.focus();
    });
}

// ---- Help panel (B3) ----
function toggleHelp() {
    helpPanel.style.display = helpPanel.style.display === 'none' ? 'block' : 'none';
}

function buildHelp() {
    helpPanel.innerHTML = '';
    const addSection = (title, items) => {
        if (!items || !items.length) return;
        const h4 = document.createElement('h4');
        h4.textContent = title;
        helpPanel.appendChild(h4);
        for (const item of items) {
            const d = document.createElement('div');
            d.className = 'help-list';
            d.textContent = item;
            helpPanel.appendChild(d);
        }
    };

    addSection(s('help_items_header'), (cfg.items || []).map(item => {
        const itemAliases = Object.entries(cfg.aliases || {}).filter(([,v]) => v === item).map(([k]) => k);
        return itemAliases.length ? item + '  (' + itemAliases.join(', ') + ')' : item;
    }));
    addSection(s('help_locations_header'), cfg.locations || []);
    addSection(s('help_commands_header'), [
        'Ctrl+Enter: ' + s('review_parse_btn'),
    ]);

    // Field codes
    if (cfg.ui && cfg.ui.field_codes) {
        const codes = Object.entries(cfg.ui.field_codes).map(([letter, field]) => {
            const name = (cfg.ui.field_display_names && cfg.ui.field_display_names[field]) || field;
            return letter + ' = ' + name;
        });
        addSection(s('help_field_codes_header'), codes);
    }
}

// ---- Render ----
function renderAll() {
    renderTable();
    renderButtons();
}

function renderTable() {
    output.innerHTML = '';
    if (!state.rows.length && !state.notes.length && !state.unparseable.length) {
        if (state.phase === 'parsed') {
            output.innerHTML = '<div class="warn">' + s('nothing_to_display') + '</div>';
        }
        return;
    }

    if (state.rows.length) {
        const fields = cfg.field_order || cfg.ui.field_order || ['date','inv_type','qty','trans_type','vehicle_sub_unit','batch','notes'];
        const headers = cfg.ui.table_headers || ['#','DATE','ITEM','QTY','TYPE','LOCATION','BATCH','NOTES'];
        const tbl = document.createElement('table');

        // Header
        const thead = document.createElement('thead');
        const hr = document.createElement('tr');
        const thNum = document.createElement('th');
        thNum.textContent = headers[0] || '#';
        hr.appendChild(thNum);
        for (let i = 0; i < fields.length; i++) {
            const th = document.createElement('th');
            th.textContent = headers[i + 1] || fields[i];
            hr.appendChild(th);
        }
        const thDel = document.createElement('th');
        thDel.textContent = '';
        thDel.style.width = '30px';
        hr.appendChild(thDel);
        thead.appendChild(hr);
        tbl.appendChild(thead);

        // Body
        const tbody = document.createElement('tbody');
        for (let ri = 0; ri < state.rows.length; ri++) {
            const row = state.rows[ri];
            const tr = document.createElement('tr');
            const hasWarning = rowHasWarning(row);

            const tdNum = document.createElement('td');
            tdNum.className = 'row-num';
            tdNum.textContent = (hasWarning ? '\u26a0 ' : '') + (ri + 1);
            tr.appendChild(tdNum);

            for (const field of fields) {
                const td = document.createElement('td');
                let val = row[field];
                if (val == null) val = '???';
                if (field === 'qty' && row._container) {
                    td.textContent = val + ' [' + row._container + '?]';
                } else {
                    td.textContent = String(val);
                }
                if (String(val) === '???' || val == null) td.classList.add('warn');
                td.onclick = () => startEdit(td, ri, field);
                tr.appendChild(td);
            }

            const tdDel = document.createElement('td');
            tdDel.className = 'delete-btn';
            tdDel.textContent = '\u00d7';
            tdDel.title = 'Delete row';
            tdDel.onclick = () => doDelete(ri);
            tr.appendChild(tdDel);

            tbody.appendChild(tr);
        }
        tbl.appendChild(tbody);
        output.appendChild(tbl);
    }

    for (const note of (state.notes || [])) {
        const d = document.createElement('div');
        d.className = 'note';
        d.textContent = '\ud83d\udcdd ' + s('note_prefix') + ': "' + note + '"';
        output.appendChild(d);
    }

    for (const u of (state.unparseable || [])) {
        const d = document.createElement('div');
        d.className = 'unparse';
        d.textContent = '\u26a0 ' + s('unparseable_prefix') + ': "' + u + '"';
        output.appendChild(d);
    }
}

function showStatus(msg) {
    const d = document.createElement('div');
    d.className = 'status';
    d.textContent = msg;
    output.appendChild(d);
    setTimeout(() => d.remove(), 5000);
}

function showError(msg) {
    const d = document.createElement('div');
    d.className = 'error';
    d.textContent = String(msg);
    output.appendChild(d);
    setTimeout(() => d.remove(), 5000);
}

// ---- Keyboard shortcuts ----
rawInput.addEventListener('keydown', e => {
    if (e.key === 'Enter' && e.ctrlKey) {
        e.preventDefault();
        doParse();
    }
});
</script>
</body>
</html>
